syntax = "proto3";
// Automatically generated by goyang https://github.com/openconfig/goyang
// compiled 2017-10-20T19:54:39Z
// do not delete the next line
// goyang-version 1
// module "ietf-interfaces"
// revision "2014-05-08"
// namespace "urn:ietf:params:xml:ns:yang:ietf-interfaces"

// This module contains a collection of YANG definitions for
// managing network interfaces.
// 
// Copyright (c) 2014 IETF Trust and the persons identified as
// authors of the code.  All rights reserved.
// 
// Redistribution and use in source and binary forms, with or
// without modification, is permitted pursuant to, and subject
// to the license terms contained in, the Simplified BSD License
// set forth in Section 4.c of the IETF Trust's Legal Provisions
// Relating to IETF Documents
// (http://trustee.ietf.org/license-info).
// 
// This version of this YANG module is part of RFC 7223; see
// the RFC itself for full legal notices.
package ietf_interfaces;

// Interface configuration parameters.
message Interfaces {
  // The list of configured interfaces on the device.
  // 
  // The operational state of an interface is available in the
  // /interfaces-state/interface list.  If the configuration of a
  // system-controlled interface cannot be used by the system
  // (e.g., the interface hardware present does not match the
  // interface type), then the configuration is not applied to
  // the system-controlled interface shown in the
  // /interfaces-state/interface list.  If the configuration
  // of a user-controlled interface cannot be used by the system,
  // the configured interface is not instantiated in the
  // /interfaces-state/interface list.
  repeated Interfaces_Interface interface = 1;
}

// The list of configured interfaces on the device.
// 
// The operational state of an interface is available in the
// /interfaces-state/interface list.  If the configuration of a
// system-controlled interface cannot be used by the system
// (e.g., the interface hardware present does not match the
// interface type), then the configuration is not applied to
// the system-controlled interface shown in the
// /interfaces-state/interface list.  If the configuration
// of a user-controlled interface cannot be used by the system,
// the configured interface is not instantiated in the
// /interfaces-state/interface list.
message Interfaces_Interface {
  // A textual description of the interface.
  // 
  // A server implementation MAY map this leaf to the ifAlias
  // MIB object.  Such an implementation needs to use some
  // mechanism to handle the differences in size and characters
  // allowed between this leaf and ifAlias.  The definition of
  // such a mechanism is outside the scope of this document.
  // 
  // Since ifAlias is defined to be stored in non-volatile
  // storage, the MIB implementation MUST map ifAlias to the
  // value of 'description' in the persistently stored
  // datastore.
  // 
  // Specifically, if the device supports ':startup', when
  // ifAlias is read the device MUST return the value of
  // 'description' in the 'startup' datastore, and when it is
  // written, it MUST be written to the 'running' and 'startup'
  // datastores.  Note that it is up to the implementation to
  // 
  // decide whether to modify this single leaf in 'startup' or
  // perform an implicit copy-config from 'running' to
  // 'startup'.
  // 
  // If the device does not support ':startup', ifAlias MUST
  // be mapped to the 'description' leaf in the 'running'
  // datastore.
  string description = 1;
  // This leaf contains the configured, desired state of the
  // interface.
  // 
  // Systems that implement the IF-MIB use the value of this
  // leaf in the 'running' datastore to set
  // IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
  // has been initialized, as described in RFC 2863.
  // 
  // Changes in this leaf in the 'running' datastore are
  // reflected in ifAdminStatus, but if ifAdminStatus is
  // changed over SNMP, this leaf is not affected.
  bool enabled = 2;
  // Controls whether linkUp/linkDown SNMP notifications
  // should be generated for this interface.
  // 
  // If this node is not configured, the value 'enabled' is
  // operationally used by the server for interfaces that do
  // not operate on top of any other interface (i.e., there are
  // no 'lower-layer-if' entries), and 'disabled' otherwise.
  enum LinkUpDownTrapEnable {
    LinkUpDownTrapEnable_DISABLED = 0;
    LinkUpDownTrapEnable_ENABLED = 1;
  };
  LinkUpDownTrapEnable link_up_down_trap_enable = 3;
  // The name of the interface.
  // 
  // A device MAY restrict the allowed values for this leaf,
  // possibly depending on the type of the interface.
  // For system-controlled interfaces, this leaf is the
  // device-specific name of the interface.  The 'config false'
  // list /interfaces-state/interface contains the currently
  // existing interfaces on the device.
  // 
  // If a client tries to create configuration for a
  // system-controlled interface that is not present in the
  // /interfaces-state/interface list, the server MAY reject
  // the request if the implementation does not support
  // pre-provisioning of interfaces or if the name refers to
  // an interface that can never exist in the system.  A
  // NETCONF server MUST reply with an rpc-error with the
  // error-tag 'invalid-value' in this case.
  // 
  // If the device supports pre-provisioning of interface
  // configuration, the 'pre-provisioning' feature is
  // advertised.
  // 
  // If the device allows arbitrarily named user-controlled
  // interfaces, the 'arbitrary-names' feature is advertised.
  // 
  // When a configured user-controlled interface is created by
  // the system, it is instantiated with the same name in the
  // /interface-state/interface list.
  string name = 4;
  // The type of the interface.
  // 
  // When an interface entry is created, a server MAY
  // initialize the type leaf with a valid value, e.g., if it
  // is possible to derive the type from the name of the
  // interface.
  // 
  // If a client tries to set the type of an interface to a
  // value that can never be used by the system, e.g., if the
  // type is not supported or if the type does not match the
  // name of the interface, the server MUST reject the request.
  // A NETCONF server MUST reply with an rpc-error with the
  // error-tag 'invalid-value' in this case.
  string type = 5;
}

// Data nodes for the operational state of interfaces.
message InterfacesState {
  // The list of interfaces on the device.
  // 
  // System-controlled interfaces created by the system are
  // always present in this list, whether they are configured or
  // not.
  repeated InterfacesState_Interface interface = 1;
}

// The list of interfaces on the device.
// 
// System-controlled interfaces created by the system are
// always present in this list, whether they are configured or
// not.
message InterfacesState_Interface {
  // The desired state of the interface.
  // 
  // This leaf has the same read semantics as ifAdminStatus.
  enum AdminStatus {
    AdminStatus_DOWN = 0;
    AdminStatus_TESTING = 1;
    AdminStatus_UP = 2;
  };
  AdminStatus admin_status = 1;
  // A list of references to interfaces layered on top of this
  // interface.
  repeated string higher_layer_if = 2;
  // The ifIndex value for the ifEntry represented by this
  // interface.
  int32 if_index = 3;
  // The time the interface entered its current operational
  // state.  If the current state was entered prior to the
  // last re-initialization of the local network management
  // subsystem, then this node is not present.
  string last_change = 4;
  // A list of references to interfaces layered underneath this
  // interface.
  repeated string lower_layer_if = 5;
  // The name of the interface.
  // 
  // A server implementation MAY map this leaf to the ifName
  // MIB object.  Such an implementation needs to use some
  // mechanism to handle the differences in size and characters
  // allowed between this leaf and ifName.  The definition of
  // such a mechanism is outside the scope of this document.
  string name = 6;
  // The current operational state of the interface.
  // 
  // This leaf has the same semantics as ifOperStatus.
  enum OperStatus {
    OperStatus_DORMANT = 0;
    OperStatus_DOWN = 1;
    OperStatus_LOWER_LAYER_DOWN = 2;
    OperStatus_NOT_PRESENT = 3;
    OperStatus_TESTING = 4;
    OperStatus_UNKNOWN = 5;
    OperStatus_UP = 6;
  };
  OperStatus oper_status = 7;
  // The interface's address at its protocol sub-layer.  For
  // example, for an 802.x interface, this object normally
  // contains a Media Access Control (MAC) address.  The
  // interface's media-specific modules must define the bit
  // 
  // and byte ordering and the format of the value of this
  // object.  For interfaces that do not have such an address
  // (e.g., a serial line), this node is not present.
  string phys_address = 8;
  // An estimate of the interface's current bandwidth in bits
  // per second.  For interfaces that do not vary in
  // bandwidth or for those where no accurate estimation can
  // be made, this node should contain the nominal bandwidth.
  // For interfaces that have no concept of bandwidth, this
  // node is not present.
  uint64 speed = 9;
  // A collection of interface-related statistics objects.
  InterfacesState_Interface_Statistics statistics = 10;
  // The type of the interface.
  string type = 11;
}

// A collection of interface-related statistics objects.
message InterfacesState_Interface_Statistics {
  // The time on the most recent occasion at which any one or
  // more of this interface's counters suffered a
  // discontinuity.  If no such discontinuities have occurred
  // since the last re-initialization of the local management
  // subsystem, then this node contains the time the local
  // management subsystem re-initialized itself.
  string discontinuity_time = 1;
  // The number of packets, delivered by this sub-layer to a
  // higher (sub-)layer, that were addressed to a broadcast
  // address at this sub-layer.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint64 in_broadcast_pkts = 2;
  // The number of inbound packets that were chosen to be
  // discarded even though no errors had been detected to
  // prevent their being deliverable to a higher-layer
  // protocol.  One possible reason for discarding such a
  // packet could be to free up buffer space.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint32 in_discards = 3;
  // For packet-oriented interfaces, the number of inbound
  // packets that contained errors preventing them from being
  // deliverable to a higher-layer protocol.  For character-
  // oriented or fixed-length interfaces, the number of
  // inbound transmission units that contained errors
  // preventing them from being deliverable to a higher-layer
  // protocol.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint32 in_errors = 4;
  // The number of packets, delivered by this sub-layer to a
  // higher (sub-)layer, that were addressed to a multicast
  // address at this sub-layer.  For a MAC-layer protocol,
  // this includes both Group and Functional addresses.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint64 in_multicast_pkts = 5;
  // The total number of octets received on the interface,
  // including framing characters.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint64 in_octets = 6;
  // The number of packets, delivered by this sub-layer to a
  // higher (sub-)layer, that were not addressed to a
  // multicast or broadcast address at this sub-layer.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint64 in_unicast_pkts = 7;
  // For packet-oriented interfaces, the number of packets
  // received via the interface that were discarded because
  // of an unknown or unsupported protocol.  For
  // character-oriented or fixed-length interfaces that
  // support protocol multiplexing, the number of
  // transmission units received via the interface that were
  // discarded because of an unknown or unsupported protocol.
  // For any interface that does not support protocol
  // multiplexing, this counter is not present.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint32 in_unknown_protos = 8;
  // The total number of packets that higher-level protocols
  // requested be transmitted, and that were addressed to a
  // broadcast address at this sub-layer, including those
  // that were discarded or not sent.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint64 out_broadcast_pkts = 9;
  // The number of outbound packets that were chosen to be
  // discarded even though no errors had been detected to
  // prevent their being transmitted.  One possible reason
  // for discarding such a packet could be to free up buffer
  // space.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint32 out_discards = 10;
  // For packet-oriented interfaces, the number of outbound
  // packets that could not be transmitted because of errors.
  // For character-oriented or fixed-length interfaces, the
  // number of outbound transmission units that could not be
  // transmitted because of errors.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint32 out_errors = 11;
  // The total number of packets that higher-level protocols
  // requested be transmitted, and that were addressed to a
  // multicast address at this sub-layer, including those
  // that were discarded or not sent.  For a MAC-layer
  // protocol, this includes both Group and Functional
  // addresses.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint64 out_multicast_pkts = 12;
  // The total number of octets transmitted out of the
  // interface, including framing characters.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint64 out_octets = 13;
  // The total number of packets that higher-level protocols
  // requested be transmitted, and that were not addressed
  // to a multicast or broadcast address at this sub-layer,
  // including those that were discarded or not sent.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'discontinuity-time'.
  uint64 out_unicast_pkts = 14;
}

// Do not delete the lines below, they preserve tag information for goyang.
// goyang-tag Interfaces interface/Interfaces_Interface[] 1
// goyang-tag InterfacesState interface/InterfacesState_Interface[] 1
// goyang-tag InterfacesState_Interface admin_status/AdminStatus 1
// goyang-tag InterfacesState_Interface higher_layer_if/string[] 2
// goyang-tag InterfacesState_Interface if_index/int32 3
// goyang-tag InterfacesState_Interface last_change/string 4
// goyang-tag InterfacesState_Interface lower_layer_if/string[] 5
// goyang-tag InterfacesState_Interface name/string 6
// goyang-tag InterfacesState_Interface oper_status/OperStatus 7
// goyang-tag InterfacesState_Interface phys_address/string 8
// goyang-tag InterfacesState_Interface speed/uint64 9
// goyang-tag InterfacesState_Interface statistics/InterfacesState_Interface_Statistics 10
// goyang-tag InterfacesState_Interface type/string 11
// goyang-tag InterfacesState_Interface_Statistics discontinuity_time/string 1
// goyang-tag InterfacesState_Interface_Statistics in_broadcast_pkts/uint64 2
// goyang-tag InterfacesState_Interface_Statistics in_discards/uint32 3
// goyang-tag InterfacesState_Interface_Statistics in_errors/uint32 4
// goyang-tag InterfacesState_Interface_Statistics in_multicast_pkts/uint64 5
// goyang-tag InterfacesState_Interface_Statistics in_octets/uint64 6
// goyang-tag InterfacesState_Interface_Statistics in_unicast_pkts/uint64 7
// goyang-tag InterfacesState_Interface_Statistics in_unknown_protos/uint32 8
// goyang-tag InterfacesState_Interface_Statistics out_broadcast_pkts/uint64 9
// goyang-tag InterfacesState_Interface_Statistics out_discards/uint32 10
// goyang-tag InterfacesState_Interface_Statistics out_errors/uint32 11
// goyang-tag InterfacesState_Interface_Statistics out_multicast_pkts/uint64 12
// goyang-tag InterfacesState_Interface_Statistics out_octets/uint64 13
// goyang-tag InterfacesState_Interface_Statistics out_unicast_pkts/uint64 14
// goyang-tag Interfaces_Interface description/string 1
// goyang-tag Interfaces_Interface enabled/bool 2
// goyang-tag Interfaces_Interface link_up_down_trap_enable/LinkUpDownTrapEnable 3
// goyang-tag Interfaces_Interface name/string 4
// goyang-tag Interfaces_Interface type/string 5
