syntax = "proto3";
// Automatically generated by goyang https://github.com/openconfig/goyang
// compiled 2017-10-11T15:50:48Z
// do not delete the next line
// goyang-version 1
// module "ietf-network"
// revision "2017-09-19"
// namespace "urn:ietf:params:xml:ns:yang:ietf-network"

// This module defines a common base data model for a collection
// of nodes in a network. Node definitions are further used
// in network topologies and inventories.
// 
// Copyright (c) 2017 IETF Trust and the persons identified as
// authors of the code.  All rights reserved.
// 
// Redistribution and use in source and binary forms, with or
// without modification, is permitted pursuant to, and subject
// to the license terms contained in, the Simplified BSD License
// set forth in Section 4.c of the IETF Trust's Legal Provisions
// Relating to IETF Documents
// (http://trustee.ietf.org/license-info).
// 
// This version of this YANG module is part of
// draft-ietf-i2rs-yang-network-topo-16;
// see the RFC itself for full legal notices.
// 
// NOTE TO RFC EDITOR: Please replace above reference to
// draft-ietf-i2rs-yang-network-topo-16 with RFC
// number when published (i.e. RFC xxxx).
package ietf_network;

// Serves as top-level container for a list of networks.
message Networks {
  // Describes a network.
  // A network typically contains an inventory of nodes,
  // topological information (augmented through
  // network-topology data model), as well as layering
  // information.
  repeated Networks_Network network = 1;
}

// Describes a network.
// A network typically contains an inventory of nodes,
// topological information (augmented through
// network-topology data model), as well as layering
// information.
message Networks_Network {
  // A network link connects a local (source) node and
  // a remote (destination) node via a set of
  // the respective node's termination points.
  // It is possible to have several links between the same
  // source and destination nodes.  Likewise, a link could
  // potentially be re-homed between termination points.
  // Therefore, in order to ensure that we would always know
  // to distinguish between links, every link is identified by
  // a dedicated link identifier.  Note that a link models a
  // point-to-point link, not a multipoint link.
  repeated Network_Link link = 1;
  // Identifies a network.
  string network_id = 2;
  // Serves as an augmentation target.
  // The network type is indicated through corresponding
  // presence containers augmented into this container.
  Network_NetworkTypes network_types = 3;
  // The inventory of nodes of this network.
  repeated Network_Node node = 4;
  // An underlay network, used to represent layered network
  // topologies.
  repeated Network_SupportingNetwork supporting_network = 5;
}

// A network link connects a local (source) node and
// a remote (destination) node via a set of
// the respective node's termination points.
// It is possible to have several links between the same
// source and destination nodes.  Likewise, a link could
// potentially be re-homed between termination points.
// Therefore, in order to ensure that we would always know
// to distinguish between links, every link is identified by
// a dedicated link identifier.  Note that a link models a
// point-to-point link, not a multipoint link.
message Network_Link {
  // This container holds the logical destination of a
  // particular link.
  Network_Link_Destination destination = 1;
  // The identifier of a link in the topology.
  // A link is specific to a topology to which it belongs.
  string link_id = 2;
  // This container holds the logical source of a particular
  // link.
  Network_Link_Source source = 3;
  // Identifies the link, or links, that this link
  // is dependent on.
  repeated Network_Link_SupportingLink supporting_link = 4;
}

// This container holds the logical destination of a
// particular link.
message Network_Link_Destination {
  // Destination node identifier, must be in the same
  // network.
  string dest_node = 1;
  // Termination point within destination node that
  // terminates the link.
  string dest_tp = 2;
}

// This container holds the logical source of a particular
// link.
message Network_Link_Source {
  // Source node identifier, must be in same topology.
  string source_node = 1;
  // Termination point within source node that terminates
  // the link.
  string source_tp = 2;
}

// Identifies the link, or links, that this link
// is dependent on.
message Network_Link_SupportingLink {
  // This leaf identifies a link which is a part
  // of this link's underlay. Reference loops in which
  // a link identifies itself as its underlay, either
  // directly or transitively, are not allowed.
  string link_ref = 1;
  // This leaf identifies in which underlay topology
  // the supporting link is present.
  string network_ref = 2;
}

// Serves as an augmentation target.
// The network type is indicated through corresponding
// presence containers augmented into this container.
message Network_NetworkTypes {
}

// The inventory of nodes of this network.
message Network_Node {
  // Identifies a node uniquely within the containing
  // network.
  string node_id = 1;
  // Represents another node, in an underlay network, that
  // this node is supported by.  Used to represent layering
  // structure.
  repeated Network_Node_SupportingNode supporting_node = 2;
  // A termination point can terminate a link.
  // Depending on the type of topology, a termination point
  // could, for example, refer to a port or an interface.
  repeated Network_Node_TerminationPoint termination_point = 3;
}

// Represents another node, in an underlay network, that
// this node is supported by.  Used to represent layering
// structure.
message Network_Node_SupportingNode {
  // References the underlay network that the
  // underlay node is part of.
  string network_ref = 1;
  // References the underlay node itself.
  string node_ref = 2;
}

// A termination point can terminate a link.
// Depending on the type of topology, a termination point
// could, for example, refer to a port or an interface.
message Network_Node_TerminationPoint {
  // This list identifies any termination points that
  // the termination point is dependent on, or maps onto.
  // Those termination points will themselves be contained
  // in a supporting node.
  // This dependency information can be inferred from
  // the dependencies between links.  For this reason,
  // this item is not separately configurable.  Hence no
  // corresponding constraint needs to be articulated.
  // The corresponding information is simply provided by the
  // implementing system.
  repeated Network_Node_TerminationPoint_SupportingTerminationPoint supporting_termination_point = 1;
  // Termination point identifier.
  string tp_id = 2;
}

// This list identifies any termination points that
// the termination point is dependent on, or maps onto.
// Those termination points will themselves be contained
// in a supporting node.
// This dependency information can be inferred from
// the dependencies between links.  For this reason,
// this item is not separately configurable.  Hence no
// corresponding constraint needs to be articulated.
// The corresponding information is simply provided by the
// implementing system.
message Network_Node_TerminationPoint_SupportingTerminationPoint {
  // This leaf identifies in which topology the
  // supporting termination point is present.
  string network_ref = 1;
  // This leaf identifies in which node the supporting
  // termination point is present.
  string node_ref = 2;
  // Reference to the underlay node, must be in a
  // different topology
  string tp_ref = 3;
}

// An underlay network, used to represent layered network
// topologies.
message Network_SupportingNetwork {
  // References the underlay network.
  string network_ref = 1;
}


// Do not delete the lines below, they preserve tag information for goyang.
// goyang-tag Network_Link destination/Network_Link_Destination 1
// goyang-tag Network_Link link_id/string 2
// goyang-tag Network_Link source/Network_Link_Source 3
// goyang-tag Network_Link supporting_link/Network_Link_SupportingLink[] 4
// goyang-tag Network_Link_Destination dest_node/string 1
// goyang-tag Network_Link_Destination dest_tp/string 2
// goyang-tag Network_Link_Source source_node/string 1
// goyang-tag Network_Link_Source source_tp/string 2
// goyang-tag Network_Link_SupportingLink link_ref/string 1
// goyang-tag Network_Link_SupportingLink network_ref/string 2
// goyang-tag Network_Node node_id/string 1
// goyang-tag Network_Node supporting_node/Network_Node_SupportingNode[] 2
// goyang-tag Network_Node termination_point/Network_Node_TerminationPoint[] 3
// goyang-tag Network_Node_SupportingNode network_ref/string 1
// goyang-tag Network_Node_SupportingNode node_ref/string 2
// goyang-tag Network_Node_TerminationPoint supporting_termination_point/Network_Node_TerminationPoint_SupportingTerminationPoint[] 1
// goyang-tag Network_Node_TerminationPoint tp_id/string 2
// goyang-tag Network_Node_TerminationPoint_SupportingTerminationPoint network_ref/string 1
// goyang-tag Network_Node_TerminationPoint_SupportingTerminationPoint node_ref/string 2
// goyang-tag Network_Node_TerminationPoint_SupportingTerminationPoint tp_ref/string 3
// goyang-tag Network_SupportingNetwork network_ref/string 1
// goyang-tag Networks network/Networks_Network[] 1
// goyang-tag Networks_Network link/Network_Link[] 1
// goyang-tag Networks_Network network_id/string 2
// goyang-tag Networks_Network network_types/Network_NetworkTypes 3
// goyang-tag Networks_Network node/Network_Node[] 4
// goyang-tag Networks_Network supporting_network/Network_SupportingNetwork[] 5
