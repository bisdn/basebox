syntax = "proto3";
// Automatically generated by goyang https://github.com/openconfig/goyang
// compiled 2017-10-20T19:54:39Z
// do not delete the next line
// goyang-version 1
// module "openconfig-interfaces"
// revision "2017-07-14"
// revision "2017-04-03"
// revision "2016-12-22"
// namespace "http://openconfig.net/yang/interfaces"

// Model for managing network interfaces and subinterfaces.  This
// module also defines convenience types / groupings for other
// models to create references to interfaces:
// 
//  base-interface-ref (type) -  reference to a base interface
//  interface-ref (grouping) -  container for reference to a
//    interface + subinterface
//  interface-ref-state (grouping) - container for read-only
//    (opstate) reference to interface + subinterface
// 
// This model reuses data items defined in the IETF YANG model for
// interfaces described by RFC 7223 with an alternate structure
// (particularly for operational state data) and with
// additional configuration items.
// 
// Portions of this code were derived from IETF RFC 7223.
// Please reproduce this note if possible.
// 
// IETF code is subject to the following copyright and license:
// Copyright (c) IETF Trust and the persons identified as authors of
// the code.
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, is permitted pursuant to, and subject to the license
// terms contained in, the Simplified BSD License set forth in
// Section 4.c of the IETF Trust's Legal Provisions Relating
// to IETF Documents (http://trustee.ietf.org/license-info).
package openconfig_interfaces;

// Top level container for interfaces, including configuration
// and state data.
message Interfaces {
  // The list of named interfaces on the device.
  repeated Interfaces_Interface interface = 1;
}

// The list of named interfaces on the device.
message Interfaces_Interface {
  // Configurable items at the global, physical interface
  // level
  Interface_Config config = 1;
  // Top-level container for hold-time settings to enable
  // dampening advertisements of interface transitions.
  Interface_HoldTime hold_time = 2;
  // References the configured name of the interface
  string name = 3;
  // Operational state data at the global interface level
  Interface_State state = 4;
  // Enclosing container for the list of subinterfaces associated
  // with a physical interface
  Interface_Subinterfaces subinterfaces = 5;
}

// Configurable items at the global, physical interface
// level
message Interface_Config {
  // A textual description of the interface.
  // 
  // A server implementation MAY map this leaf to the ifAlias
  // MIB object.  Such an implementation needs to use some
  // mechanism to handle the differences in size and characters
  // allowed between this leaf and ifAlias.  The definition of
  // such a mechanism is outside the scope of this document.
  // 
  // Since ifAlias is defined to be stored in non-volatile
  // storage, the MIB implementation MUST map ifAlias to the
  // value of 'description' in the persistently stored
  // datastore.
  // 
  // Specifically, if the device supports ':startup', when
  // ifAlias is read the device MUST return the value of
  // 'description' in the 'startup' datastore, and when it is
  // written, it MUST be written to the 'running' and 'startup'
  // datastores.  Note that it is up to the implementation to
  // 
  // decide whether to modify this single leaf in 'startup' or
  // perform an implicit copy-config from 'running' to
  // 'startup'.
  // 
  // If the device does not support ':startup', ifAlias MUST
  // be mapped to the 'description' leaf in the 'running'
  // datastore.
  string description = 1;
  // This leaf contains the configured, desired state of the
  // interface.
  // 
  // Systems that implement the IF-MIB use the value of this
  // leaf in the 'running' datastore to set
  // IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
  // has been initialized, as described in RFC 2863.
  // 
  // Changes in this leaf in the 'running' datastore are
  // reflected in ifAdminStatus, but if ifAdminStatus is
  // changed over SNMP, this leaf is not affected.
  bool enabled = 2;
  // Set the max transmission unit size in octets
  // for the physical interface.  If this is not set, the mtu is
  // set to the operational default -- e.g., 1514 bytes on an
  // Ethernet interface.
  uint32 mtu = 3;
  // The name of the interface.
  // 
  // A device MAY restrict the allowed values for this leaf,
  // possibly depending on the type of the interface.
  // For system-controlled interfaces, this leaf is the
  // device-specific name of the interface.  The 'config false'
  // list interfaces/interface[name]/state contains the currently
  // existing interfaces on the device.
  // 
  // If a client tries to create configuration for a
  // system-controlled interface that is not present in the
  // corresponding state list, the server MAY reject
  // the request if the implementation does not support
  // pre-provisioning of interfaces or if the name refers to
  // an interface that can never exist in the system.  A
  // NETCONF server MUST reply with an rpc-error with the
  // error-tag 'invalid-value' in this case.
  // 
  // The IETF model in RFC 7223 provides YANG features for the
  // following (i.e., pre-provisioning and arbitrary-names),
  // however they are omitted here:
  // 
  //  If the device supports pre-provisioning of interface
  //  configuration, the 'pre-provisioning' feature is
  //  advertised.
  // 
  //  If the device allows arbitrarily named user-controlled
  //  interfaces, the 'arbitrary-names' feature is advertised.
  // 
  // When a configured user-controlled interface is created by
  // the system, it is instantiated with the same name in the
  // /interfaces/interface[name]/state list.
  string name = 4;
  // The type of the interface.
  // 
  // When an interface entry is created, a server MAY
  // initialize the type leaf with a valid value, e.g., if it
  // is possible to derive the type from the name of the
  // interface.
  // 
  // If a client tries to set the type of an interface to a
  // value that can never be used by the system, e.g., if the
  // type is not supported or if the type does not match the
  // name of the interface, the server MUST reject the request.
  // A NETCONF server MUST reply with an rpc-error with the
  // error-tag 'invalid-value' in this case.
  string type = 5;
}

// Top-level container for hold-time settings to enable
// dampening advertisements of interface transitions.
message Interface_HoldTime {
  // Configuration data for interface hold-time settings.
  Interface_HoldTime_Config config = 1;
  // Operational state data for interface hold-time.
  Interface_HoldTime_State state = 2;
}

// Configuration data for interface hold-time settings.
message Interface_HoldTime_Config {
  // Dampens advertisement when the interface transitions from
  // up to down.  A zero value means dampening is turned off,
  // i.e., immediate notification.
  uint32 down = 1;
  // Dampens advertisement when the interface
  // transitions from down to up.  A zero value means dampening
  // is turned off, i.e., immediate notification.
  uint32 up = 2;
}

// Operational state data for interface hold-time.
message Interface_HoldTime_State {
  // Dampens advertisement when the interface transitions from
  // up to down.  A zero value means dampening is turned off,
  // i.e., immediate notification.
  uint32 down = 1;
  // Dampens advertisement when the interface
  // transitions from down to up.  A zero value means dampening
  // is turned off, i.e., immediate notification.
  uint32 up = 2;
}

// Operational state data at the global interface level
message Interface_State {
  // The desired state of the interface.  In RFC 7223 this leaf
  // has the same read semantics as ifAdminStatus.  Here, it
  // reflects the administrative state as set by enabling or
  // disabling the interface.
  enum AdminStatus {
    AdminStatus_DOWN = 0;
    AdminStatus_TESTING = 1;
    AdminStatus_UP = 2;
  };
  AdminStatus admin_status = 1;
  // A collection of interface-related statistics objects.
  Interface_State_Counters counters = 2;
  // A textual description of the interface.
  // 
  // A server implementation MAY map this leaf to the ifAlias
  // MIB object.  Such an implementation needs to use some
  // mechanism to handle the differences in size and characters
  // allowed between this leaf and ifAlias.  The definition of
  // such a mechanism is outside the scope of this document.
  // 
  // Since ifAlias is defined to be stored in non-volatile
  // storage, the MIB implementation MUST map ifAlias to the
  // value of 'description' in the persistently stored
  // datastore.
  // 
  // Specifically, if the device supports ':startup', when
  // ifAlias is read the device MUST return the value of
  // 'description' in the 'startup' datastore, and when it is
  // written, it MUST be written to the 'running' and 'startup'
  // datastores.  Note that it is up to the implementation to
  // 
  // decide whether to modify this single leaf in 'startup' or
  // perform an implicit copy-config from 'running' to
  // 'startup'.
  // 
  // If the device does not support ':startup', ifAlias MUST
  // be mapped to the 'description' leaf in the 'running'
  // datastore.
  string description = 3;
  // This leaf contains the configured, desired state of the
  // interface.
  // 
  // Systems that implement the IF-MIB use the value of this
  // leaf in the 'running' datastore to set
  // IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
  // has been initialized, as described in RFC 2863.
  // 
  // Changes in this leaf in the 'running' datastore are
  // reflected in ifAdminStatus, but if ifAdminStatus is
  // changed over SNMP, this leaf is not affected.
  bool enabled = 4;
  // System assigned number for each interface.  Corresponds to
  // ifIndex object in SNMP Interface MIB
  uint32 ifindex = 5;
  // This timestamp indicates the time of the last state change
  // of the interface (e.g., up-to-down transition). This
  // corresponds to the ifLastChange object in the standard
  // interface MIB.
  // 
  // The value is the timestamp in nanoseconds relative to
  // the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
  uint64 last_change = 6;
  // Set the max transmission unit size in octets
  // for the physical interface.  If this is not set, the mtu is
  // set to the operational default -- e.g., 1514 bytes on an
  // Ethernet interface.
  uint32 mtu = 7;
  // The name of the interface.
  // 
  // A device MAY restrict the allowed values for this leaf,
  // possibly depending on the type of the interface.
  // For system-controlled interfaces, this leaf is the
  // device-specific name of the interface.  The 'config false'
  // list interfaces/interface[name]/state contains the currently
  // existing interfaces on the device.
  // 
  // If a client tries to create configuration for a
  // system-controlled interface that is not present in the
  // corresponding state list, the server MAY reject
  // the request if the implementation does not support
  // pre-provisioning of interfaces or if the name refers to
  // an interface that can never exist in the system.  A
  // NETCONF server MUST reply with an rpc-error with the
  // error-tag 'invalid-value' in this case.
  // 
  // The IETF model in RFC 7223 provides YANG features for the
  // following (i.e., pre-provisioning and arbitrary-names),
  // however they are omitted here:
  // 
  //  If the device supports pre-provisioning of interface
  //  configuration, the 'pre-provisioning' feature is
  //  advertised.
  // 
  //  If the device allows arbitrarily named user-controlled
  //  interfaces, the 'arbitrary-names' feature is advertised.
  // 
  // When a configured user-controlled interface is created by
  // the system, it is instantiated with the same name in the
  // /interfaces/interface[name]/state list.
  string name = 8;
  // The current operational state of the interface.
  // 
  // This leaf has the same semantics as ifOperStatus.
  enum OperStatus {
    OperStatus_DORMANT = 0;
    OperStatus_DOWN = 1;
    OperStatus_LOWER_LAYER_DOWN = 2;
    OperStatus_NOT_PRESENT = 3;
    OperStatus_TESTING = 4;
    OperStatus_UNKNOWN = 5;
    OperStatus_UP = 6;
  };
  OperStatus oper_status = 9;
  // The type of the interface.
  // 
  // When an interface entry is created, a server MAY
  // initialize the type leaf with a valid value, e.g., if it
  // is possible to derive the type from the name of the
  // interface.
  // 
  // If a client tries to set the type of an interface to a
  // value that can never be used by the system, e.g., if the
  // type is not supported or if the type does not match the
  // name of the interface, the server MUST reject the request.
  // A NETCONF server MUST reply with an rpc-error with the
  // error-tag 'invalid-value' in this case.
  string type = 10;
}

// A collection of interface-related statistics objects.
message Interface_State_Counters {
  // Number of times the interface state has transitioned
  // between up and down since the time the device restarted
  // or the last-clear time, whichever is most recent.
  uint64 carrier_transitions = 1;
  // The number of packets, delivered by this sub-layer to a
  // higher (sub-)layer, that were addressed to a broadcast
  // address at this sub-layer.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_broadcast_pkts = 2;
  // The number of inbound packets that were chosen to be
  // discarded even though no errors had been detected to
  // prevent their being deliverable to a higher-layer
  // protocol.  One possible reason for discarding such a
  // packet could be to free up buffer space.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_discards = 3;
  // For packet-oriented interfaces, the number of inbound
  // packets that contained errors preventing them from being
  // deliverable to a higher-layer protocol.  For character-
  // oriented or fixed-length interfaces, the number of
  // inbound transmission units that contained errors
  // preventing them from being deliverable to a higher-layer
  // protocol.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_errors = 4;
  // Number of received packets which had errors in the
  // frame check sequence (FCS), i.e., framing errors.
  // 
  // Discontinuities in the value of this counter can occur
  // when the device is re-initialization as indicated by the
  // value of 'last-clear'.
  uint64 in_fcs_errors = 5;
  // The number of packets, delivered by this sub-layer to a
  // higher (sub-)layer, that were addressed to a multicast
  // address at this sub-layer.  For a MAC-layer protocol,
  // this includes both Group and Functional addresses.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_multicast_pkts = 6;
  // The total number of octets received on the interface,
  // including framing characters.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_octets = 7;
  // The number of packets, delivered by this sub-layer to a
  // higher (sub-)layer, that were not addressed to a
  // multicast or broadcast address at this sub-layer.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_unicast_pkts = 8;
  // For packet-oriented interfaces, the number of packets
  // received via the interface that were discarded because
  // of an unknown or unsupported protocol.  For
  // character-oriented or fixed-length interfaces that
  // support protocol multiplexing, the number of
  // transmission units received via the interface that were
  // discarded because of an unknown or unsupported protocol.
  // For any interface that does not support protocol
  // multiplexing, this counter is not present.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_unknown_protos = 9;
  // Timestamp of the last time the interface counters were
  // cleared.
  // 
  // The value is the timestamp in nanoseconds relative to
  // the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
  uint64 last_clear = 10;
  // The total number of packets that higher-level protocols
  // requested be transmitted, and that were addressed to a
  // broadcast address at this sub-layer, including those
  // that were discarded or not sent.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_broadcast_pkts = 11;
  // The number of outbound packets that were chosen to be
  // discarded even though no errors had been detected to
  // prevent their being transmitted.  One possible reason
  // for discarding such a packet could be to free up buffer
  // space.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_discards = 12;
  // For packet-oriented interfaces, the number of outbound
  // packets that could not be transmitted because of errors.
  // For character-oriented or fixed-length interfaces, the
  // number of outbound transmission units that could not be
  // transmitted because of errors.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_errors = 13;
  // The total number of packets that higher-level protocols
  // requested be transmitted, and that were addressed to a
  // multicast address at this sub-layer, including those
  // that were discarded or not sent.  For a MAC-layer
  // protocol, this includes both Group and Functional
  // addresses.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_multicast_pkts = 14;
  // The total number of octets transmitted out of the
  // interface, including framing characters.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_octets = 15;
  // The total number of packets that higher-level protocols
  // requested be transmitted, and that were not addressed
  // to a multicast or broadcast address at this sub-layer,
  // including those that were discarded or not sent.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_unicast_pkts = 16;
}

// Enclosing container for the list of subinterfaces associated
// with a physical interface
message Interface_Subinterfaces {
  // The list of subinterfaces (logical interfaces) associated
  // with a physical interface
  repeated Interface_Subinterfaces_Subinterface subinterface = 1;
}

// The list of subinterfaces (logical interfaces) associated
// with a physical interface
message Interface_Subinterfaces_Subinterface {
  // Configurable items at the subinterface level
  Interface_Subinterface_Config config = 1;
  // The index number of the subinterface -- used to address
  // the logical interface
  string index = 2;
  // Operational state data for logical interfaces
  Interface_Subinterface_State state = 3;
}

// Configurable items at the subinterface level
message Interface_Subinterface_Config {
  // A textual description of the interface.
  // 
  // A server implementation MAY map this leaf to the ifAlias
  // MIB object.  Such an implementation needs to use some
  // mechanism to handle the differences in size and characters
  // allowed between this leaf and ifAlias.  The definition of
  // such a mechanism is outside the scope of this document.
  // 
  // Since ifAlias is defined to be stored in non-volatile
  // storage, the MIB implementation MUST map ifAlias to the
  // value of 'description' in the persistently stored
  // datastore.
  // 
  // Specifically, if the device supports ':startup', when
  // ifAlias is read the device MUST return the value of
  // 'description' in the 'startup' datastore, and when it is
  // written, it MUST be written to the 'running' and 'startup'
  // datastores.  Note that it is up to the implementation to
  // 
  // decide whether to modify this single leaf in 'startup' or
  // perform an implicit copy-config from 'running' to
  // 'startup'.
  // 
  // If the device does not support ':startup', ifAlias MUST
  // be mapped to the 'description' leaf in the 'running'
  // datastore.
  string description = 1;
  // This leaf contains the configured, desired state of the
  // interface.
  // 
  // Systems that implement the IF-MIB use the value of this
  // leaf in the 'running' datastore to set
  // IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
  // has been initialized, as described in RFC 2863.
  // 
  // Changes in this leaf in the 'running' datastore are
  // reflected in ifAdminStatus, but if ifAdminStatus is
  // changed over SNMP, this leaf is not affected.
  bool enabled = 2;
  // The index of the subinterface, or logical interface number.
  // On systems with no support for subinterfaces, or not using
  // subinterfaces, this value should default to 0, i.e., the
  // default subinterface.
  uint32 index = 3;
}

// Operational state data for logical interfaces
message Interface_Subinterface_State {
  // The desired state of the interface.  In RFC 7223 this leaf
  // has the same read semantics as ifAdminStatus.  Here, it
  // reflects the administrative state as set by enabling or
  // disabling the interface.
  enum AdminStatus {
    AdminStatus_DOWN = 0;
    AdminStatus_TESTING = 1;
    AdminStatus_UP = 2;
  };
  AdminStatus admin_status = 1;
  // A collection of interface-related statistics objects.
  Interface_Subinterface_State_Counters counters = 2;
  // A textual description of the interface.
  // 
  // A server implementation MAY map this leaf to the ifAlias
  // MIB object.  Such an implementation needs to use some
  // mechanism to handle the differences in size and characters
  // allowed between this leaf and ifAlias.  The definition of
  // such a mechanism is outside the scope of this document.
  // 
  // Since ifAlias is defined to be stored in non-volatile
  // storage, the MIB implementation MUST map ifAlias to the
  // value of 'description' in the persistently stored
  // datastore.
  // 
  // Specifically, if the device supports ':startup', when
  // ifAlias is read the device MUST return the value of
  // 'description' in the 'startup' datastore, and when it is
  // written, it MUST be written to the 'running' and 'startup'
  // datastores.  Note that it is up to the implementation to
  // 
  // decide whether to modify this single leaf in 'startup' or
  // perform an implicit copy-config from 'running' to
  // 'startup'.
  // 
  // If the device does not support ':startup', ifAlias MUST
  // be mapped to the 'description' leaf in the 'running'
  // datastore.
  string description = 3;
  // This leaf contains the configured, desired state of the
  // interface.
  // 
  // Systems that implement the IF-MIB use the value of this
  // leaf in the 'running' datastore to set
  // IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
  // has been initialized, as described in RFC 2863.
  // 
  // Changes in this leaf in the 'running' datastore are
  // reflected in ifAdminStatus, but if ifAdminStatus is
  // changed over SNMP, this leaf is not affected.
  bool enabled = 4;
  // System assigned number for each interface.  Corresponds to
  // ifIndex object in SNMP Interface MIB
  uint32 ifindex = 5;
  // The index of the subinterface, or logical interface number.
  // On systems with no support for subinterfaces, or not using
  // subinterfaces, this value should default to 0, i.e., the
  // default subinterface.
  uint32 index = 6;
  // This timestamp indicates the time of the last state change
  // of the interface (e.g., up-to-down transition). This
  // corresponds to the ifLastChange object in the standard
  // interface MIB.
  // 
  // The value is the timestamp in nanoseconds relative to
  // the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
  uint64 last_change = 7;
  // The system-assigned name for the sub-interface.  This MAY
  // be a combination of the base interface name and the
  // subinterface index, or some other convention used by the
  // system.
  string name = 8;
  // The current operational state of the interface.
  // 
  // This leaf has the same semantics as ifOperStatus.
  enum OperStatus {
    OperStatus_DORMANT = 0;
    OperStatus_DOWN = 1;
    OperStatus_LOWER_LAYER_DOWN = 2;
    OperStatus_NOT_PRESENT = 3;
    OperStatus_TESTING = 4;
    OperStatus_UNKNOWN = 5;
    OperStatus_UP = 6;
  };
  OperStatus oper_status = 9;
}

// A collection of interface-related statistics objects.
message Interface_Subinterface_State_Counters {
  // Number of times the interface state has transitioned
  // between up and down since the time the device restarted
  // or the last-clear time, whichever is most recent.
  uint64 carrier_transitions = 1;
  // The number of packets, delivered by this sub-layer to a
  // higher (sub-)layer, that were addressed to a broadcast
  // address at this sub-layer.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_broadcast_pkts = 2;
  // The number of inbound packets that were chosen to be
  // discarded even though no errors had been detected to
  // prevent their being deliverable to a higher-layer
  // protocol.  One possible reason for discarding such a
  // packet could be to free up buffer space.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_discards = 3;
  // For packet-oriented interfaces, the number of inbound
  // packets that contained errors preventing them from being
  // deliverable to a higher-layer protocol.  For character-
  // oriented or fixed-length interfaces, the number of
  // inbound transmission units that contained errors
  // preventing them from being deliverable to a higher-layer
  // protocol.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_errors = 4;
  // Number of received packets which had errors in the
  // frame check sequence (FCS), i.e., framing errors.
  // 
  // Discontinuities in the value of this counter can occur
  // when the device is re-initialization as indicated by the
  // value of 'last-clear'.
  uint64 in_fcs_errors = 5;
  // The number of packets, delivered by this sub-layer to a
  // higher (sub-)layer, that were addressed to a multicast
  // address at this sub-layer.  For a MAC-layer protocol,
  // this includes both Group and Functional addresses.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_multicast_pkts = 6;
  // The total number of octets received on the interface,
  // including framing characters.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_octets = 7;
  // The number of packets, delivered by this sub-layer to a
  // higher (sub-)layer, that were not addressed to a
  // multicast or broadcast address at this sub-layer.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_unicast_pkts = 8;
  // For packet-oriented interfaces, the number of packets
  // received via the interface that were discarded because
  // of an unknown or unsupported protocol.  For
  // character-oriented or fixed-length interfaces that
  // support protocol multiplexing, the number of
  // transmission units received via the interface that were
  // discarded because of an unknown or unsupported protocol.
  // For any interface that does not support protocol
  // multiplexing, this counter is not present.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 in_unknown_protos = 9;
  // Timestamp of the last time the interface counters were
  // cleared.
  // 
  // The value is the timestamp in nanoseconds relative to
  // the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
  uint64 last_clear = 10;
  // The total number of packets that higher-level protocols
  // requested be transmitted, and that were addressed to a
  // broadcast address at this sub-layer, including those
  // that were discarded or not sent.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_broadcast_pkts = 11;
  // The number of outbound packets that were chosen to be
  // discarded even though no errors had been detected to
  // prevent their being transmitted.  One possible reason
  // for discarding such a packet could be to free up buffer
  // space.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_discards = 12;
  // For packet-oriented interfaces, the number of outbound
  // packets that could not be transmitted because of errors.
  // For character-oriented or fixed-length interfaces, the
  // number of outbound transmission units that could not be
  // transmitted because of errors.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_errors = 13;
  // The total number of packets that higher-level protocols
  // requested be transmitted, and that were addressed to a
  // multicast address at this sub-layer, including those
  // that were discarded or not sent.  For a MAC-layer
  // protocol, this includes both Group and Functional
  // addresses.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_multicast_pkts = 14;
  // The total number of octets transmitted out of the
  // interface, including framing characters.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_octets = 15;
  // The total number of packets that higher-level protocols
  // requested be transmitted, and that were not addressed
  // to a multicast or broadcast address at this sub-layer,
  // including those that were discarded or not sent.
  // 
  // Discontinuities in the value of this counter can occur
  // at re-initialization of the management system, and at
  // other times as indicated by the value of
  // 'last-clear'.
  uint64 out_unicast_pkts = 16;
}

// Do not delete the lines below, they preserve tag information for goyang.
// goyang-tag Interface_Config description/string 1
// goyang-tag Interface_Config enabled/bool 2
// goyang-tag Interface_Config mtu/uint32 3
// goyang-tag Interface_Config name/string 4
// goyang-tag Interface_Config type/string 5
// goyang-tag Interface_HoldTime config/Interface_HoldTime_Config 1
// goyang-tag Interface_HoldTime state/Interface_HoldTime_State 2
// goyang-tag Interface_HoldTime_Config down/uint32 1
// goyang-tag Interface_HoldTime_Config up/uint32 2
// goyang-tag Interface_HoldTime_State down/uint32 1
// goyang-tag Interface_HoldTime_State up/uint32 2
// goyang-tag Interface_State admin_status/AdminStatus 1
// goyang-tag Interface_State counters/Interface_State_Counters 2
// goyang-tag Interface_State description/string 3
// goyang-tag Interface_State enabled/bool 4
// goyang-tag Interface_State ifindex/uint32 5
// goyang-tag Interface_State last_change/uint64 6
// goyang-tag Interface_State mtu/uint32 7
// goyang-tag Interface_State name/string 8
// goyang-tag Interface_State oper_status/OperStatus 9
// goyang-tag Interface_State type/string 10
// goyang-tag Interface_State_Counters carrier_transitions/uint64 1
// goyang-tag Interface_State_Counters in_broadcast_pkts/uint64 2
// goyang-tag Interface_State_Counters in_discards/uint64 3
// goyang-tag Interface_State_Counters in_errors/uint64 4
// goyang-tag Interface_State_Counters in_fcs_errors/uint64 5
// goyang-tag Interface_State_Counters in_multicast_pkts/uint64 6
// goyang-tag Interface_State_Counters in_octets/uint64 7
// goyang-tag Interface_State_Counters in_unicast_pkts/uint64 8
// goyang-tag Interface_State_Counters in_unknown_protos/uint64 9
// goyang-tag Interface_State_Counters last_clear/uint64 10
// goyang-tag Interface_State_Counters out_broadcast_pkts/uint64 11
// goyang-tag Interface_State_Counters out_discards/uint64 12
// goyang-tag Interface_State_Counters out_errors/uint64 13
// goyang-tag Interface_State_Counters out_multicast_pkts/uint64 14
// goyang-tag Interface_State_Counters out_octets/uint64 15
// goyang-tag Interface_State_Counters out_unicast_pkts/uint64 16
// goyang-tag Interface_Subinterface_Config description/string 1
// goyang-tag Interface_Subinterface_Config enabled/bool 2
// goyang-tag Interface_Subinterface_Config index/uint32 3
// goyang-tag Interface_Subinterface_State admin_status/AdminStatus 1
// goyang-tag Interface_Subinterface_State counters/Interface_Subinterface_State_Counters 2
// goyang-tag Interface_Subinterface_State description/string 3
// goyang-tag Interface_Subinterface_State enabled/bool 4
// goyang-tag Interface_Subinterface_State ifindex/uint32 5
// goyang-tag Interface_Subinterface_State index/uint32 6
// goyang-tag Interface_Subinterface_State last_change/uint64 7
// goyang-tag Interface_Subinterface_State name/string 8
// goyang-tag Interface_Subinterface_State oper_status/OperStatus 9
// goyang-tag Interface_Subinterface_State_Counters carrier_transitions/uint64 1
// goyang-tag Interface_Subinterface_State_Counters in_broadcast_pkts/uint64 2
// goyang-tag Interface_Subinterface_State_Counters in_discards/uint64 3
// goyang-tag Interface_Subinterface_State_Counters in_errors/uint64 4
// goyang-tag Interface_Subinterface_State_Counters in_fcs_errors/uint64 5
// goyang-tag Interface_Subinterface_State_Counters in_multicast_pkts/uint64 6
// goyang-tag Interface_Subinterface_State_Counters in_octets/uint64 7
// goyang-tag Interface_Subinterface_State_Counters in_unicast_pkts/uint64 8
// goyang-tag Interface_Subinterface_State_Counters in_unknown_protos/uint64 9
// goyang-tag Interface_Subinterface_State_Counters last_clear/uint64 10
// goyang-tag Interface_Subinterface_State_Counters out_broadcast_pkts/uint64 11
// goyang-tag Interface_Subinterface_State_Counters out_discards/uint64 12
// goyang-tag Interface_Subinterface_State_Counters out_errors/uint64 13
// goyang-tag Interface_Subinterface_State_Counters out_multicast_pkts/uint64 14
// goyang-tag Interface_Subinterface_State_Counters out_octets/uint64 15
// goyang-tag Interface_Subinterface_State_Counters out_unicast_pkts/uint64 16
// goyang-tag Interface_Subinterfaces subinterface/Interface_Subinterfaces_Subinterface[] 1
// goyang-tag Interface_Subinterfaces_Subinterface config/Interface_Subinterface_Config 1
// goyang-tag Interface_Subinterfaces_Subinterface index/string 2
// goyang-tag Interface_Subinterfaces_Subinterface state/Interface_Subinterface_State 3
// goyang-tag Interfaces interface/Interfaces_Interface[] 1
// goyang-tag Interfaces_Interface config/Interface_Config 1
// goyang-tag Interfaces_Interface hold_time/Interface_HoldTime 2
// goyang-tag Interfaces_Interface name/string 3
// goyang-tag Interfaces_Interface state/Interface_State 4
// goyang-tag Interfaces_Interface subinterfaces/Interface_Subinterfaces 5
